/*
 * Copyright 2021 Cyface GmbH
 *
 * This file is part of the Cyface Publish Plugin for Android.
 *
 * The Cyface Publish Plugin for Android is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * The Cyface Publish Plugin for Android is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with the Cyface Publish Plugin for Android. If not, see <http://www.gnu.org/licenses/>.
 */

plugins {
    id 'com.android.library'
    id 'maven-publish'
}

/*
 * The following code for publication was contributed by an external source (RM) back in 2017
 * or 2018. It was heavily refactored on 25th of August 2021 to work with Gradle 7.0.2. From this
 * refactoring it seems that the code creating Javadoc and Source Files did never work at all, which
 * was not checked. It did contain spelling mistakes, which caused no errors due to the dynamic
 * nature of the Groovy language.
 * The biggest problem was that it was not compatible with the current way Gradle likes tasks to be
 * created. The refactoring tries to substitute the old call to the task() method with calls to the
 * more dynamic tasks.named() and tasks.register(). The benefit is that tasks are created on demand
 * which should speed up the build process if certain tasks are not needed at all.
 * See: https://docs.gradle.org/7.2/userguide/more_about_tasks.html
 *
 * The goal of this code is to create artifacts for publication only for the two release variants for
 * Cyface and Movebis. Each Artifact is packaged together with its Javadoc and Sources for easy
 * reference.
 */

/**
 * Identify variants which are not of interest in the publication process.
 *
 * @param variant The variant from `android.libraryVariants`
 * @return `true` if this variant can be skipped in release
 */
static def isDebugOrMock(variant) {
    def isDebug = variant.buildType.name == 'debug'
    def isMock = variant.flavorName?.contains('Mock')
    return isDebug || isMock
}

/**
 * Selects one variant per module to generate exactly one javadoc/sources.jar.
 *
 * For `cyface-de/android-backend` datacapturing and synchronization module the variant
 * `movebisFullRelease` is selected and for the persistence module the variant `release`.
 *
 * @param variant
 * @return
 */
static def isVariantForDocs(variant) {
    return variant.name == 'movebisFullRelease' || variant.name == 'release'
}

/**
 * Only generate one sources and javadoc jar per module.
 *
 * Before switching to Gradle 8 we generates one per variant but with identical names, i.e. they
 * did overwrite themselves. When switching to Gradle 8 this does not work anymore as we need to
 * define each dependency explicitly and this way the javadocsJar of another flavor is used. We
 * tried to generate a variant-specific Javadoc/SourcesJar but they contain the same bytes anyways.
 * and with
 * - `def kebabCaseName = variant.name.replaceAll("([a-z])([A-Z]+)", '$1-$2').toLowerCase()` and
 * - `archiveClassifier.set(kebabCaseName + '-javadoc')` in this section and
 * - `classifier kebabCaseName + '-javadoc'` in the publications section
 * the jars are named like `datacapturing-cyface-full-release-javadoc.jar` which do not apply to the
 * naming convention and no links are added to the POM by gradle. Thus, we only generate a variant-
 * unspecific javadoc/sources jar.
 *
 * But we need to use `libraryVariants` for this as there is no possibility anymore to define the
 * classpath without variant context. Our workaround is to select one specific variant.
 */
project.android.libraryVariants.all { variant ->
    if (!isVariantForDocs(variant)) {
        return
    }

    // Setup Javadoc and source tasks for all build variants.
    def javaDocDestDir = layout.buildDirectory.dir("docs/javadoc")
    // Using `tasks.create` as with `task.register` the `destinationDir` is not found
    def javadoc = tasks.create("javadoc", Javadoc) {
        description "Generates Javadoc."
        source = android.sourceSets.main.java.srcDirs
        destinationDir = javaDocDestDir
        classpath += files(android.getBootClasspath().join(File.pathSeparator))
        def compileClassPath = variant.javaCompileProvider.get().classpath
        classpath += files(compileClassPath)
        exclude '**/BuildConfig.java'
        exclude '**/R.java'
        failOnError false
    }

    tasks.register("javadocJar", Jar) {
        dependsOn "javadoc"
        description "Puts Javadoc in a jar"
        archiveClassifier.set('javadoc')
        from javadoc.destinationDir
    }

    def sourceDirs = android.sourceSets.collect {
        it.javaDirectories // includes Kotlin sources
    }

    tasks.register("sourcesJar", Jar) {
        description "Puts sources in jar"
        from sourceDirs
        archiveClassifier.set('sources')
    }
}

// This is probably required to run Javadoc and Source creation on each invocation of publish
publish.dependsOn 'assemble'

publishing {
       // Authenticate at the repository
        repositories {
            maven {
                url = uri("https://maven.pkg.github.com/cyface-de/android-backend")
                credentials {
                    username = project.findProperty("githubUser").toString()
                    password = project.findProperty("githubToken").toString()
                }
            }
        }

    // Ensure publication tasks depend on Javadoc and sources generation
    afterEvaluate {
        project.android.libraryVariants.all { variant ->
            if (isDebugOrMock(variant)) {
                return
            }

            def variantNameCapitalized = variant.name.capitalize()
            def bundleTaskName = "bundle${variantNameCapitalized}Aar"

            def projectName = "${project.name.capitalize()}"

            tasks.named("publish${projectName}${variantNameCapitalized}PublicationToMavenRepository").configure {
                dependsOn tasks.named(bundleTaskName),
                        tasks.named("javadocJar"),
                        tasks.named("sourcesJar")

            }

            tasks.named("publish${projectName}${variantNameCapitalized}PublicationToMavenLocal").configure {
                dependsOn tasks.named(bundleTaskName),
                        tasks.named("javadocJar"),
                        tasks.named("sourcesJar")
            }
        }
    }

    // Create publications for all release variants.
    publications {
        project.android.libraryVariants.all { variant ->
            if (isDebugOrMock(variant)) {
                return
            }

            // Configure artifacts
            "${project.name}${variant.name.capitalize()}"(MavenPublication) {
                groupId = 'de.cyface'
                // The artifactId must not contain upper case chars [STAD-234]
                artifactId "${project.name}${variant.flavorName.contains('movebis') ? 'movebis' : ''}"
                project.logger.lifecycle('artifactId: ' + artifactId)
                version android.defaultConfig.versionName

                // Add main artifact
                artifact(variant.packageLibraryProvider.get().archivePath)

                // Put javadoc and sources into jar
                artifact(tasks["javadocJar"].outputs.files.singleFile) {
                    classifier 'javadoc'
                }
                artifact(tasks["sourcesJar"].outputs.files.singleFile) {
                    classifier 'sources'
                }

                // Logging for diagnostic purposes
                project.logger.lifecycle("Configuring publication for variant: $variant.name with ArtifactId: $artifactId")
            }
        }
    }
}
